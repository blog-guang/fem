# æ¶æ„è®¾è®¡ (Software Architecture)

æœ¬æ–‡æ¡£æè¿° FEM è½¯ä»¶çš„æ•´ä½“æ¶æ„è®¾è®¡ï¼ŒåŸºäº ANSYS Mechanical çš„å·¥ç¨‹å®è·µï¼Œå¹¶èå…¥ç°ä»£ C++ è®¾è®¡ç†å¿µã€‚

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. **æ¨¡å—åŒ–**ï¼šé«˜å†…èšã€ä½è€¦åˆï¼Œæ˜“äºæ‰©å±•
2. **æ€§èƒ½**ï¼šé€‚ç”¨äºå¤§è§„æ¨¡å·¥ç¨‹é—®é¢˜ï¼ˆç™¾ä¸‡çº§ DOFï¼‰
3. **æ­£ç¡®æ€§**ï¼šä¸¥æ ¼éªŒè¯ï¼Œä¸ ANSYS ç»“æœå¯¹æ ‡
4. **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„ä»£ç ç»“æ„ï¼Œå®Œå–„çš„æ–‡æ¡£
5. **å¯æ‰©å±•æ€§**ï¼šå·¥å‚æ¨¡å¼ï¼Œæ˜“äºæ·»åŠ æ–°ææ–™/å•å…ƒ/æ±‚è§£å™¨

---

## ğŸ“ æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç”¨æˆ·æ¥å£å±‚ (User Interface)              â”‚
â”‚  - Python API (æœªæ¥)                                         â”‚
â”‚  - C++ ç›´æ¥è°ƒç”¨                                              â”‚
â”‚  - é…ç½®æ–‡ä»¶è¾“å…¥                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰å¤„ç†å±‚ (Preprocessing)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  Geometry  â”‚  â”‚   Mesher    â”‚  â”‚  Boundary    â”‚           â”‚
â”‚  â”‚  (CAD I/O) â”‚  â”‚  (Tetgen)   â”‚  â”‚  Conditions  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ±‚è§£å™¨å±‚ (Solver Core)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Physics Modules (ç‰©ç†æ¨¡å—)                            â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ Elasticityâ”‚  â”‚  Thermal  â”‚  â”‚ Contact â”‚  â”‚ Modal  â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Assembly (è£…é…)                                       â”‚  â”‚
â”‚  â”‚  - Element loop (å•å…ƒå¾ªç¯)                             â”‚  â”‚
â”‚  â”‚  - Sparse matrix building (ç¨€ç–çŸ©é˜µæ„å»º)              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Solvers (æ±‚è§£å™¨)                                      â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚   CG     â”‚  â”‚   PCG     â”‚  â”‚ Newton   â”‚  â”‚ Lanczos â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åå¤„ç†å±‚ (Postprocessing)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Stress   â”‚  â”‚  Strain   â”‚  â”‚ Reaction  â”‚  â”‚  Fatigue  â”‚   â”‚
â”‚  â”‚ Extractionâ”‚  â”‚Extraction â”‚  â”‚  Forces   â”‚  â”‚ Analysis  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Visualization (å¯è§†åŒ–)                               â”‚  â”‚
â”‚  â”‚  - VTK export                                         â”‚  â”‚
â”‚  â”‚  - ParaView integration                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. Core (æ ¸å¿ƒå·¥å…·)

**ä½ç½®**: `src/core/`

**èŒè´£**ï¼š
- åŸºæœ¬ç±»å‹å®šä¹‰ (`types.h`: Real, Index, Vec3, ...)
- æ—¥å¿—ç³»ç»Ÿ (`logger.h/cpp`)
- è®¡æ—¶å™¨ (`timer.h/cpp`)

**è®¾è®¡åŸåˆ™**ï¼š
- æœ€å°ä¾èµ–ï¼Œå…¶ä»–æ¨¡å—éƒ½ä¾èµ– core
- ç±»å‹å®šä¹‰é›†ä¸­ç®¡ç†ï¼Œä¾¿äºåˆ‡æ¢ç²¾åº¦ï¼ˆfloat/doubleï¼‰

---

### 2. Math (æ•°å­¦åº“)

**ä½ç½®**: `src/math/`

**æ¨¡å—**ï¼š
```
math/
â”œâ”€â”€ vector.h/cpp              # å‘é‡ç±»ï¼ˆè¿ç®—ç¬¦é‡è½½ï¼‰
â”œâ”€â”€ dense_matrix.h/cpp        # ç¨ å¯†çŸ©é˜µ
â”œâ”€â”€ sparse_matrix.h/cpp       # ç¨€ç–çŸ©é˜µï¼ˆCOO, CSRï¼‰
â”œâ”€â”€ solver.h/cpp              # æ±‚è§£å™¨åŸºç±»
â”œâ”€â”€ solver_factory.h/cpp      # æ±‚è§£å™¨å·¥å‚
â”œâ”€â”€ cg.h/cpp                  # å…±è½­æ¢¯åº¦
â”œâ”€â”€ pcg.h/cpp                 # é¢„æ¡ä»¶å…±è½­æ¢¯åº¦
â”œâ”€â”€ bicgstab.h/cpp            # BiCGSTAB
â””â”€â”€ newton_raphson.h/cpp      # éçº¿æ€§æ±‚è§£å™¨
```

**è®¾è®¡äº®ç‚¹**ï¼š
- **Vector è¿ç®—ç¬¦é‡è½½**ï¼š`x += alpha * p` æ›¿ä»£æ‰‹å†™å¾ªç¯
- **å·¥å‚æ¨¡å¼**ï¼š`SolverFactory::create("PCG", params)`
- **ç­–ç•¥æ¨¡å¼**ï¼šé¢„æ¡ä»¶å™¨å¯æ’æ‹”ï¼ˆJacobi, SSOR, ILU, AMGï¼‰

**æ¥å£ç¤ºä¾‹**ï¼š
```cpp
// åˆ›å»ºæ±‚è§£å™¨
auto solver = SolverFactory::create("PCG", {
    {"tol", 1e-8},
    {"max_iter", 1000}
}, {
    {"precond", "amg"}
});

// æ±‚è§£çº¿æ€§ç³»ç»Ÿ
Vector x(n, 0.0);
auto result = solver->solve(K, F, x);
```

---

### 3. Material (ææ–™ç³»ç»Ÿ)

**ä½ç½®**: `src/material/`

**æ¨¡å—**ï¼š
```
material/
â”œâ”€â”€ material.h/cpp                    # ææ–™åŸºç±»
â”œâ”€â”€ material_factory.h/cpp            # ææ–™å·¥å‚
â”œâ”€â”€ isotropic_elastic.h/cpp           # å„å‘åŒæ€§å¼¹æ€§
â”œâ”€â”€ orthotropic_elastic.h/cpp         # æ­£äº¤å¼‚æ€§å¼¹æ€§
â”œâ”€â”€ j2_plasticity.h/cpp               # J2 å¡‘æ€§ï¼ˆç­‰å‘ç¡¬åŒ–ï¼‰
â”œâ”€â”€ j2_plasticity_kinematic.h/cpp     # J2 å¡‘æ€§ï¼ˆéšåŠ¨ç¡¬åŒ–ï¼‰
â””â”€â”€ state_variables.h/cpp             # çŠ¶æ€å˜é‡ç®¡ç†
```

**è®¾è®¡å“²å­¦**ï¼š
- **åŸºç±»å®šä¹‰ç»Ÿä¸€æ¥å£**ï¼š`computeStress()`, `computeTangent()`
- **å·¥å‚æ¨¡å¼åˆ›å»º**ï¼š`MaterialFactory::create("J2Plasticity", params)`
- **çŠ¶æ€å˜é‡ç®¡ç†**ï¼šå¡‘æ€§åº”å˜ã€ç¡¬åŒ–å‚æ•°ç­‰å†å²å˜é‡

**ææ–™æ¥å£**ï¼š
```cpp
class Material {
public:
    virtual void computeStress(
        const Vector& strain_inc,  // åº”å˜å¢é‡
        Vector& stress,             // è¾“å‡ºï¼šåº”åŠ›
        StateVariables& state       // è¾“å…¥è¾“å‡ºï¼šçŠ¶æ€å˜é‡
    ) = 0;
    
    virtual void computeTangent(
        const Vector& strain,       // å½“å‰åº”å˜
        DenseMatrix& D_mat,         // è¾“å‡ºï¼šåˆ‡çº¿åˆšåº¦
        const StateVariables& state
    ) = 0;
};
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```cpp
// åˆ›å»ºææ–™
auto mat = MaterialFactory::create("J2Plasticity", {
    {"E", 200e9},
    {"nu", 0.3},
    {"sigma_y", 250e6},
    {"H", 1e9},
    {"dimension", 3}
});

// åº”åŠ›æ›´æ–°
Vector strain_inc(6);
Vector stress(6);
StateVariables state = mat->createState();
mat->computeStress(strain_inc, stress, state);
```

---

### 4. Shape (å½¢å‡½æ•°ç³»ç»Ÿ)

**ä½ç½®**: `src/shape/`

**æ¨¡å—**ï¼š
```
shape/
â”œâ”€â”€ shape_function.h/cpp          # å½¢å‡½æ•°åŸºç±»
â”œâ”€â”€ shape_function_factory.h/cpp  # å½¢å‡½æ•°å·¥å‚
â”œâ”€â”€ shape_tri3.h/cpp              # ä¸‰è§’å½¢å•å…ƒ
â”œâ”€â”€ shape_quad4.h/cpp             # å››è¾¹å½¢å•å…ƒ
â”œâ”€â”€ shape_tet4.h/cpp              # å››é¢ä½“å•å…ƒ
â””â”€â”€ shape_brick8.h/cpp            # å…­é¢ä½“å•å…ƒ
```

**èŒè´£**ï¼š
- å½¢å‡½æ•° `N(Î¾, Î·, Î¶)` è®¡ç®—
- å½¢å‡½æ•°å¯¼æ•° `âˆ‚N/âˆ‚Î¾, âˆ‚N/âˆ‚Î·, âˆ‚N/âˆ‚Î¶`
- é›…å¯æ¯”çŸ©é˜µ `J = âˆ‚(x,y,z)/âˆ‚(Î¾,Î·,Î¶)`
- ç‰©ç†åæ ‡å¯¼æ•° `âˆ‚N/âˆ‚x, âˆ‚N/âˆ‚y, âˆ‚N/âˆ‚z`

**é«˜æ–¯ç§¯åˆ†**ï¼š
```cpp
struct GaussPoint {
    Vec3 xi;       // å±€éƒ¨åæ ‡
    Real weight;   // ç§¯åˆ†æƒé‡
};

class ShapeFunction {
public:
    virtual std::vector<GaussPoint> gauss_points(int order) const = 0;
    virtual DenseMatrix shape_derivatives(const Vec3& xi) const = 0;
};
```

---

### 5. Mesh (ç½‘æ ¼ç³»ç»Ÿ)

**ä½ç½®**: `src/mesh/`

**æ¨¡å—**ï¼š
```
mesh/
â”œâ”€â”€ mesh.h/cpp              # ç½‘æ ¼ç±»ï¼ˆèŠ‚ç‚¹ã€å•å…ƒï¼‰
â”œâ”€â”€ model.h/cpp             # æ¨¡å‹ç±»ï¼ˆç½‘æ ¼+ææ–™+ç‰©ç†ï¼‰
â””â”€â”€ mesh_generator.h/cpp    # ç½‘æ ¼ç”Ÿæˆå™¨
```

**æ•°æ®ç»“æ„**ï¼š
```cpp
struct Node {
    Index id;
    Vec3 coords;      // åæ ‡ (x, y, z)
};

struct Element {
    Index id;
    ElementType type; // Tri3, Quad4, Tet4, Brick8, ...
    std::vector<Index> nodes;
    Index material_id;
};

class Mesh {
private:
    std::vector<Node> nodes_;
    std::vector<Element> elements_;
    std::map<std::string, std::vector<Index>> boundaries_;  // è¾¹ç•Œé›†åˆ
};
```

---

### 6. Physics (ç‰©ç†æ¨¡å—)

**ä½ç½®**: `src/physics/`

**æ¨¡å—**ï¼š
```
physics/
â”œâ”€â”€ physics_base.h/cpp            # ç‰©ç†æ¨¡å—åŸºç±»
â”œâ”€â”€ physics_factory.h/cpp         # ç‰©ç†æ¨¡å—å·¥å‚
â”œâ”€â”€ elasticity_unified.h/cpp      # å¼¹æ€§åŠ›å­¦
â””â”€â”€ heat_unified.h/cpp            # çƒ­ä¼ å¯¼
```

**èŒè´£**ï¼š
- å•å…ƒåˆšåº¦çŸ©é˜µ `Ke` è®¡ç®—
- å•å…ƒè½½è·å‘é‡ `Fe` è®¡ç®—
- B çŸ©é˜µæ„é€ ï¼ˆåº”å˜-ä½ç§»å…³ç³»ï¼‰

**æ¥å£**ï¼š
```cpp
class PhysicsBase {
public:
    virtual void compute_element(
        Index elem_id,
        const Mesh& mesh,
        DenseMatrix& Ke,  // è¾“å‡ºï¼šå•å…ƒåˆšåº¦
        Vector& Fe        // è¾“å‡ºï¼šå•å…ƒè½½è·
    ) const = 0;
};
```

**å¼¹æ€§åŠ›å­¦å®ç°**ï¼š
```cpp
class ElasticityUnified : public PhysicsBase {
public:
    ElasticityUnified(Material* material, int dimension);
    
    void compute_element(Index elem_id, const Mesh& mesh,
                        DenseMatrix& Ke, Vector& Fe) const override {
        // 1. è·å–èŠ‚ç‚¹åæ ‡
        // 2. å¾ªç¯é«˜æ–¯ç§¯åˆ†ç‚¹
        //    a. è®¡ç®—å½¢å‡½æ•°å¯¼æ•° dN/d(x,y,z)
        //    b. æ„é€  B çŸ©é˜µ
        //    c. è·å–ææ–™åˆšåº¦ D (é€šè¿‡ material_->computeTangent())
        //    d. Ke += B^T * D * B * det(J) * weight
        // 3. è¿”å› Ke
    }
};
```

---

### 7. Assembly (è£…é…å™¨)

**ä½ç½®**: `src/assembly/`

**èŒè´£**ï¼š
- å¾ªç¯æ‰€æœ‰å•å…ƒï¼Œè°ƒç”¨ `Physics::compute_element()`
- å°†å•å…ƒçŸ©é˜µè£…é…åˆ°å…¨å±€çŸ©é˜µï¼ˆCSR æ ¼å¼ï¼‰
- åº”ç”¨è¾¹ç•Œæ¡ä»¶ï¼ˆDirichletï¼‰

**æ¥å£**ï¼š
```cpp
class Assembler {
public:
    void assemble(std::function<void(Index, const Mesh&, 
                                     DenseMatrix&, Vector&)> elem_func);
    
    void apply_dirichlet(const std::map<Index, Real>& bcs);
    
    SparseMatrixCSR& matrix();
    Vector& rhs();
};
```

**ä½¿ç”¨æµç¨‹**ï¼š
```cpp
// 1. åˆ›å»ºè£…é…å™¨
Assembler assembler(mesh, dofs_per_node);

// 2. è£…é…å…¨å±€çŸ©é˜µ
assembler.assemble([&](Index id, const Mesh& mesh, 
                       DenseMatrix& Ke, Vector& Fe) {
    physics.compute_element(id, mesh, Ke, Fe);
});

// 3. åº”ç”¨è¾¹ç•Œæ¡ä»¶
assembler.apply_dirichlet(boundary_conditions);

// 4. æ±‚è§£
SparseMatrixCSR& K = assembler.matrix();
Vector& F = assembler.rhs();
Vector u;
solver->solve(K, F, u);
```

---

### 8. Postprocess (åå¤„ç†)

**ä½ç½®**: `src/postprocess/`

**æ¨¡å—**ï¼š
```
postprocess/
â”œâ”€â”€ post_processor.h/cpp               # åå¤„ç†åŸºç±»
â””â”€â”€ post_processor_incremental.h/cpp   # å¢é‡å¼åå¤„ç†
```

**åŠŸèƒ½**ï¼š
- åº”åŠ›/åº”å˜æå–ï¼ˆå•å…ƒä¸­å¿ƒã€èŠ‚ç‚¹ã€é«˜æ–¯ç‚¹ï¼‰
- von Mises ç­‰æ•ˆåº”åŠ›
- ä¸»åº”åŠ›/ä¸»æ–¹å‘
- ååŠ›è®¡ç®—
- èƒ½é‡è®¡ç®—

**æ¥å£**ï¼š
```cpp
class PostProcessor {
public:
    void compute_stress(const Vector& u, const Mesh& mesh,
                       Material* material,
                       std::vector<Vector>& element_stress);
    
    void compute_von_mises(const std::vector<Vector>& stress,
                          std::vector<Real>& von_mises);
    
    Vector compute_reaction_forces(const Vector& u,
                                   const Mesh& mesh);
};
```

---

## ğŸ”„ æ•°æ®æµç¨‹

### é™æ€ç»“æ„åˆ†ææµç¨‹

```
1. å‰å¤„ç†
   â”œâ”€ è¯»å–ç½‘æ ¼ (Mesh)
   â”œâ”€ å®šä¹‰ææ–™ (MaterialFactory)
   â”œâ”€ è®¾ç½®è¾¹ç•Œæ¡ä»¶ (Dirichlet, Neumann)
   â””â”€ åˆ›å»ºç‰©ç†æ¨¡å— (PhysicsFactory)

2. è£…é…
   â”œâ”€ åˆ›å»ºè£…é…å™¨ (Assembler)
   â”œâ”€ å¾ªç¯å•å…ƒ
   â”‚  â”œâ”€ è®¡ç®—å•å…ƒåˆšåº¦ Ke (Physics::compute_element)
   â”‚  â””â”€ è£…é…åˆ°å…¨å±€çŸ©é˜µ K
   â””â”€ åº”ç”¨è¾¹ç•Œæ¡ä»¶

3. æ±‚è§£
   â”œâ”€ åˆ›å»ºæ±‚è§£å™¨ (SolverFactory)
   â””â”€ æ±‚è§£ Ku = F

4. åå¤„ç†
   â”œâ”€ åº”åŠ›æå– (PostProcessor::compute_stress)
   â”œâ”€ von Mises åº”åŠ›
   â”œâ”€ ååŠ›è®¡ç®—
   â””â”€ å¯¼å‡º VTK
```

---

## ğŸ­ å·¥å‚æ¨¡å¼ç»Ÿä¸€

æ‰€æœ‰å¯æ‰©å±•æ¨¡å—éƒ½ä½¿ç”¨å·¥å‚æ¨¡å¼ï¼š

```cpp
// ææ–™å·¥å‚
auto mat = MaterialFactory::create("J2Plasticity", {
    {"E", 200e9}, {"nu", 0.3}, {"sigma_y", 250e6}
});

// æ±‚è§£å™¨å·¥å‚
auto solver = SolverFactory::create("PCG", 
    {{"tol", 1e-8}}, 
    {{"precond", "amg"}}
);

// ç‰©ç†æ¨¡å—å·¥å‚
auto physics = PhysicsFactory::createElasticity(mat, dimension);
```

**ä¼˜åŠ¿**ï¼š
- å­—ç¬¦ä¸²é©±åŠ¨ï¼Œæ˜“äºé…ç½®æ–‡ä»¶è§£æ
- æ˜“äºæ‰©å±•ï¼ˆ`registerCreator`ï¼‰
- ç»Ÿä¸€æ¥å£ï¼Œé™ä½å­¦ä¹ æˆæœ¬

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•ï¼ˆUnit Testsï¼‰

**ä½ç½®**: `tests/`

**è¦†ç›–**ï¼š
- æ¯ä¸ªç±»çš„å…¬å…±æ¥å£
- è¾¹ç•Œæ¡ä»¶ï¼ˆç©ºçŸ©é˜µã€å•å…ƒç´ ç­‰ï¼‰
- æ•°å€¼ç²¾åº¦éªŒè¯

**å·¥å…·**: GoogleTest

**ç¤ºä¾‹**ï¼š
```cpp
TEST(VectorTest, AdditionOperator) {
    Vector a(3);
    a[0] = 1; a[1] = 2; a[2] = 3;
    
    Vector b = a + a;
    
    EXPECT_NEAR(b[0], 2.0, 1e-10);
    EXPECT_NEAR(b[1], 4.0, 1e-10);
    EXPECT_NEAR(b[2], 6.0, 1e-10);
}
```

### éªŒè¯æµ‹è¯•ï¼ˆValidation Testsï¼‰

**å¯¹æ ‡**ï¼š
- è§£æè§£ï¼ˆç®€å•å‡ ä½•ï¼‰
- NAFEMS Benchmarks
- ANSYS ç»“æœå¯¹æ¯”

**æ¡ˆä¾‹**ï¼š
- æ‚¬è‡‚æ¢ç«¯ç‚¹ä½ç§»ï¼ˆè§£æè§£ï¼‰
- Hertz æ¥è§¦ï¼ˆè§£æè§£ï¼‰
- NAFEMS LE1ï¼ˆçº¿æ€§å¼¹æ€§ï¼‰
- NAFEMS LE10ï¼ˆè‡ªç”±æ¢ï¼‰

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ä¼˜åŒ–
- **ç¨€ç–çŸ©é˜µ**ï¼šCSR æ ¼å¼ï¼Œä»…å­˜å‚¨éé›¶å…ƒ
- **é¢„åˆ†é…**ï¼š`reserve()` é¿å…é¢‘ç¹æ‰©å®¹
- **Move semantics**ï¼šé¿å…æ‹·è´

### 2. è®¡ç®—ä¼˜åŒ–
- **è¿ç®—ç¬¦å†…è”**ï¼šç¼–è¯‘å™¨ä¼˜åŒ– `x += alpha * p`
- **BLAS åº“**ï¼šé«˜æ•ˆçŸ©é˜µ-å‘é‡ä¹˜æ³•
- **å‡ç¼©ç§¯åˆ†**ï¼šé™ä½é«˜æ–¯ç‚¹æ•°é‡ï¼ˆä»…å½“åˆç†æ—¶ï¼‰

### 3. å¹¶è¡ŒåŒ–ï¼ˆæœªæ¥ï¼‰
- **OpenMP**ï¼šå•å…ƒè£…é…å¹¶è¡Œ
- **MPI**ï¼šåŒºåŸŸåˆ†è§£
- **GPU**ï¼šæ±‚è§£å™¨åŠ é€Ÿ

---

## ğŸ“¦ ä¾èµ–ç®¡ç†

### å¿…éœ€ä¾èµ–
- **Eigen**ï¼ˆæˆ–è‡ªç ”ï¼‰ï¼šçŸ©é˜µè¿ç®—
- **AMGCL**ï¼šä»£æ•°å¤šé‡ç½‘æ ¼é¢„æ¡ä»¶å™¨

### å¯é€‰ä¾èµ–
- **Tetgen/Gmsh**ï¼šç½‘æ ¼ç”Ÿæˆ
- **VTK**ï¼šå¯è§†åŒ–
- **ParaView**ï¼šåå¤„ç†
- **PARDISO**ï¼šç›´æ¥æ±‚è§£å™¨

---

## ğŸ”® æœªæ¥æ‰©å±•

### çŸ­æœŸï¼ˆ6ä¸ªæœˆå†…ï¼‰
- Python ç»‘å®šï¼ˆpybind11ï¼‰
- GUI å‰ç«¯ï¼ˆQt/Dear ImGuiï¼‰
- é…ç½®æ–‡ä»¶é©±åŠ¨ï¼ˆYAML/JSONï¼‰

### ä¸­æœŸï¼ˆ1å¹´å†…ï¼‰
- å¤šç‰©ç†åœºè€¦åˆæ¡†æ¶
- è‡ªé€‚åº”ç½‘æ ¼ç»†åŒ–
- æ‹“æ‰‘ä¼˜åŒ–æ¨¡å—

### é•¿æœŸï¼ˆ2å¹´å†…ï¼‰
- äº‘ç«¯æ±‚è§£æœåŠ¡
- æœºå™¨å­¦ä¹ è¾…åŠ©ï¼ˆææ–™å‚æ•°è¯†åˆ«ï¼‰
- å®æ—¶ååŒä»¿çœŸ

---

**è®¾è®¡åŸåˆ™æ€»ç»“**ï¼š
1. **KISS**ï¼ˆKeep It Simple, Stupidï¼‰ï¼šä¼˜å…ˆç®€å•æ¸…æ™°çš„å®ç°
2. **DRY**ï¼ˆDon't Repeat Yourselfï¼‰ï¼šå¤ç”¨ä»£ç ï¼Œé¿å…é‡å¤
3. **SOLID**ï¼šé¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™
4. **æµ‹è¯•é©±åŠ¨**ï¼šå…ˆå†™æµ‹è¯•ï¼Œå†å†™å®ç°
5. **æ–‡æ¡£å…ˆè¡Œ**ï¼šè®¾è®¡æ–‡æ¡£æŒ‡å¯¼å¼€å‘

---

**å‚è€ƒèµ„æ–™**ï¼š
- *The Finite Element Method* - Hughes, 2000
- *ANSYS Theory Reference*
- *NAFEMS Finite Element Analysis* - Hitchings, 1994
